$date
	Mon Nov 16 15:30:55 2020
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module test $end
$var wire 4 ! sh_reg_out [3:0] $end
$var wire 5 " adder_out [4:0] $end
$var reg 1 # clk $end
$var reg 1 $ reset $end
$scope module ipc $end
$var wire 5 % adder_res [4:0] $end
$var wire 1 # clk $end
$var wire 1 $ reset $end
$var wire 4 & sh_reg_res [3:0] $end
$var wire 5 ' sh_in [4:0] $end
$var wire 4 ( adder_in [3:0] $end
$scope module adder $end
$var wire 4 ) num_one [3:0] $end
$var wire 4 * num_two [3:0] $end
$var wire 5 + S [4:0] $end
$var reg 5 , Cins [4:0] $end
$var reg 1 - cout $end
$var reg 4 . generates [3:0] $end
$var reg 4 / propagates [3:0] $end
$var reg 4 0 sum [3:0] $end
$var integer 32 1 i [31:0] $end
$var integer 32 2 j [31:0] $end
$upscope $end
$scope module shreg $end
$var wire 1 # clk $end
$var wire 5 3 in [4:0] $end
$var wire 1 $ reset $end
$var wire 4 4 out [3:0] $end
$var reg 5 5 ser [4:0] $end
$var integer 32 6 i [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx 6
b0 5
b0 4
b1101 3
b100 2
b100 1
b1101 0
b1101 /
b0 .
0-
b0 ,
b1101 +
b0 *
b1101 )
b0 (
b1101 '
b0 &
b1101 %
0$
0#
b1101 "
b0 !
$end
#1
1-
b100 2
b11000 ,
b100 .
b100 1
b10011 "
b10011 %
b10011 '
b10011 +
b10011 3
b11 0
b1011 /
b110 !
b110 &
b110 (
b110 *
b110 4
b1101 5
b101 6
1#
#2
0#
#3
1-
b100 2
b100 1
b10110 "
b10110 %
b10110 '
b10110 +
b10110 3
b110 0
b100 /
b1001 .
b10010 ,
b1001 !
b1001 &
b1001 (
b1001 *
b1001 4
b10011 5
b101 6
1#
#4
0#
#5
b100 2
b100 1
b11000 "
b11000 %
b11000 '
b11000 +
b11000 3
b1000 0
b110 /
b1001 .
b11110 ,
b1011 !
b1011 &
b1011 (
b1011 *
b1011 4
b10110 5
b101 6
1#
#6
0#
#7
1-
b100 2
b100 1
b11001 "
b11001 %
b11001 '
b11001 +
b11001 3
b1001 0
b1 /
b1100 .
b11000 ,
b1100 !
b1100 &
b1100 (
b1100 *
b1100 4
b11000 5
b101 6
1#
#8
0#
#9
b11001 5
b101 6
1#
#10
0#
#11
b11001 5
b101 6
1#
#12
0#
#13
b11001 5
b101 6
1#
#14
0#
#15
b11001 5
b101 6
1#
#16
0#
#17
b11001 5
b101 6
1#
#18
0#
#19
b11001 5
b101 6
1#
#20
0#
